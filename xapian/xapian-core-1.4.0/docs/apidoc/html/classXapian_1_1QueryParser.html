<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: Xapian::QueryParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.1.2 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceXapian.html">Xapian</a></li><li class="navelem"><a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classXapian_1_1QueryParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Xapian::QueryParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string.  
 <a href="classXapian_1_1QueryParser.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae96a58a8de9d219ca3214a5a66e0407e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">feature_flag</a> { <br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde">FLAG_BOOLEAN</a> =  1, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b">FLAG_PHRASE</a> =  2, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd">FLAG_LOVEHATE</a> =  4, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d">FLAG_BOOLEAN_ANY_CASE</a> =  8, 
<br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a> =  16, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0">FLAG_PURE_NOT</a> =  32, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a> =  64, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c">FLAG_SPELLING_CORRECTION</a> =  128, 
<br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f">FLAG_SYNONYM</a> =  256, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b">FLAG_AUTO_SYNONYMS</a> =  512, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b">FLAG_AUTO_MULTIWORD_SYNONYMS</a> =  1024, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4c83dcc06ba2cd69c81521133dc68ff8">FLAG_CJK_NGRAM</a> =  2048, 
<br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a> =  FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE
<br/>
 }</td></tr>
<tr class="memdesc:ae96a58a8de9d219ca3214a5a66e0407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of feature flags.  <a href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">More...</a><br/></td></tr>
<tr class="memitem:ae2959f7a1c5680f3fd1421d92445e220"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> </td></tr>
<tr class="memdesc:ae2959f7a1c5680f3fd1421d92445e220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stemming strategies, for use with <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy.">set_stemming_strategy()</a>. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00d9afcf20b20cd9c8b3d22dd1bc82b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a00d9afcf20b20cd9c8b3d22dd1bc82b7">QueryParser</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr class="memdesc:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="memitem:a18adb637032c2149a0457f2f79f332a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18adb637032c2149a0457f2f79f332a5"></a>
<a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a18adb637032c2149a0457f2f79f332a5">operator=</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr class="memdesc:a18adb637032c2149a0457f2f79f332a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr class="memitem:a724f1e26b785516c4c8cde78455f9cd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a724f1e26b785516c4c8cde78455f9cd5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a724f1e26b785516c4c8cde78455f9cd5">QueryParser</a> ()</td></tr>
<tr class="memdesc:a724f1e26b785516c4c8cde78455f9cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="memitem:a69d48b819b0c6d6a29f86a756f91d047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d48b819b0c6d6a29f86a756f91d047"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a69d48b819b0c6d6a29f86a756f91d047">~QueryParser</a> ()</td></tr>
<tr class="memdesc:a69d48b819b0c6d6a29f86a756f91d047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="memitem:a2312c9865a58cc1149fe7cda9f0c2585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2312c9865a58cc1149fe7cda9f0c2585">set_stemmer</a> (const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;stemmer)</td></tr>
<tr class="memdesc:a2312c9865a58cc1149fe7cda9f0c2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemmer.  <a href="#a2312c9865a58cc1149fe7cda9f0c2585"></a><br/></td></tr>
<tr class="memitem:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd">set_stemming_strategy</a> (<a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> strategy)</td></tr>
<tr class="memdesc:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemming strategy.  <a href="#ac7dc3b55b6083bd3ff98fc8b2726c8fd"></a><br/></td></tr>
<tr class="memitem:ab1046610676f72ba564108f0df5d77ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ab1046610676f72ba564108f0df5d77ab">set_stopper</a> (const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *stop=NULL)</td></tr>
<tr class="memdesc:ab1046610676f72ba564108f0df5d77ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stopper.  <a href="#ab1046610676f72ba564108f0df5d77ab"></a><br/></td></tr>
<tr class="memitem:a2efe48be88c4872afec4bc963f417ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2efe48be88c4872afec4bc963f417ea5">set_default_op</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> default_op)</td></tr>
<tr class="memdesc:a2efe48be88c4872afec4bc963f417ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default operator.  <a href="#a2efe48be88c4872afec4bc963f417ea5"></a><br/></td></tr>
<tr class="memitem:a4a6323a8aea7734e447de1ba7eab31c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a4a6323a8aea7734e447de1ba7eab31c1">get_default_op</a> () const </td></tr>
<tr class="memdesc:a4a6323a8aea7734e447de1ba7eab31c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default operator.  <a href="#a4a6323a8aea7734e447de1ba7eab31c1"></a><br/></td></tr>
<tr class="memitem:a576d221ba746506e51d9ea596ecb2cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6">set_database</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;db)</td></tr>
<tr class="memdesc:a576d221ba746506e51d9ea596ecb2cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the database being searched.  <a href="#a576d221ba746506e51d9ea596ecb2cf6"></a><br/></td></tr>
<tr class="memitem:afabe68a4eb93a05150ae7cf070d33752"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#afabe68a4eb93a05150ae7cf070d33752">set_max_expansion</a> (<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a> max_expansion, int max_type=<a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">Xapian::Query::WILDCARD_LIMIT_ERROR</a>, unsigned flags=<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a>|<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a>)</td></tr>
<tr class="memdesc:afabe68a4eb93a05150ae7cf070d33752"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the maximum expansion of a wildcard and/or partial term.  <a href="#afabe68a4eb93a05150ae7cf070d33752"></a><br/></td></tr>
<tr class="memitem:a0a2651e3363f82933b5c6e350bab6d8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a0a2651e3363f82933b5c6e350bab6d8b">set_max_wildcard_expansion</a> (<a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>)</td></tr>
<tr class="memdesc:a0a2651e3363f82933b5c6e350bab6d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the maximum expansion of a wildcard.  <a href="#a0a2651e3363f82933b5c6e350bab6d8b"></a><br/></td></tr>
<tr class="memitem:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2">parse_query</a> (const std::string &amp;query_string, unsigned flags=<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a>, const std::string &amp;default_prefix=std::string())</td></tr>
<tr class="memdesc:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a query.  <a href="#a73d32cc7f862ab2e3fdd7da61f352fb2"></a><br/></td></tr>
<tr class="memitem:ad4829ddcaa0582ff94d1066870a18c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97">add_prefix</a> (const std::string &amp;field, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ad4829ddcaa0582ff94d1066870a18c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a probabilistic term prefix.  <a href="#ad4829ddcaa0582ff94d1066870a18c97"></a><br/></td></tr>
<tr class="memitem:a3c6b58293a8e0e0d1db354362c5b7e19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3c6b58293a8e0e0d1db354362c5b7e19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a3c6b58293a8e0e0d1db354362c5b7e19">add_prefix</a> (const std::string &amp;field, <a class="el" href="classXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc)</td></tr>
<tr class="memdesc:a3c6b58293a8e0e0d1db354362c5b7e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1FieldProcessor.html" title="Base class for field processors.">FieldProcessor</a>. <br/></td></tr>
<tr class="memitem:a8590431c481fe0eea43cd4ce619a0816"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a8590431c481fe0eea43cd4ce619a0816">add_boolean_prefix</a> (const std::string &amp;field, const std::string &amp;prefix, const std::string *grouping=NULL)</td></tr>
<tr class="memdesc:a8590431c481fe0eea43cd4ce619a0816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query.  <a href="#a8590431c481fe0eea43cd4ce619a0816"></a><br/></td></tr>
<tr class="memitem:ad475afb6389e05cf996a862a9305c666"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad475afb6389e05cf996a862a9305c666"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ad475afb6389e05cf996a862a9305c666">add_boolean_prefix</a> (const std::string &amp;field, <a class="el" href="classXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc, const std::string *grouping=NULL)</td></tr>
<tr class="memdesc:ad475afb6389e05cf996a862a9305c666"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1FieldProcessor.html" title="Base class for field processors.">FieldProcessor</a> for a boolean prefix. <br/></td></tr>
<tr class="memitem:aead663f25674137f723c58b1ceaf5071"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aead663f25674137f723c58b1ceaf5071"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#aead663f25674137f723c58b1ceaf5071">add_boolean_prefix</a> (const std::string &amp;field, <a class="el" href="classXapian_1_1FieldProcessor.html">Xapian::FieldProcessor</a> *proc, bool exclusive)</td></tr>
<tr class="memdesc:aead663f25674137f723c58b1ceaf5071"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1FieldProcessor.html" title="Base class for field processors.">FieldProcessor</a> for a boolean prefix. <br/></td></tr>
<tr class="memitem:a57ff03cd3fe1fa2b6e07fc347bee3590"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57ff03cd3fe1fa2b6e07fc347bee3590"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a57ff03cd3fe1fa2b6e07fc347bee3590">stoplist_begin</a> () const </td></tr>
<tr class="memdesc:a57ff03cd3fe1fa2b6e07fc347bee3590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over terms omitted from the query as stopwords. <br/></td></tr>
<tr class="memitem:aa2088e54f557e2d608247c5237a1bc3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2088e54f557e2d608247c5237a1bc3b"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#aa2088e54f557e2d608247c5237a1bc3b">unstem_begin</a> (const std::string &amp;term) const </td></tr>
<tr class="memdesc:aa2088e54f557e2d608247c5237a1bc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over unstemmed forms of the given (stemmed) term used in the query. <br/></td></tr>
<tr class="memitem:af8e15e0a73460b2134ca202273d513b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8e15e0a73460b2134ca202273d513b9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#af8e15e0a73460b2134ca202273d513b9">add_rangeprocessor</a> (<a class="el" href="classXapian_1_1RangeProcessor.html">Xapian::RangeProcessor</a> *range_proc, const std::string *grouping=NULL)</td></tr>
<tr class="memdesc:af8e15e0a73460b2134ca202273d513b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1RangeProcessor.html" title="Base class for range processors.">RangeProcessor</a>. <br/></td></tr>
<tr class="memitem:a8f8583a9f044f2eb33859b442a8aea76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a8f8583a9f044f2eb33859b442a8aea76">add_valuerangeprocessor</a> (<a class="el" href="classXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *vrproc)</td></tr>
<tr class="memdesc:a8f8583a9f044f2eb33859b442a8aea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="classXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors.">ValueRangeProcessor</a>.  <a href="#a8f8583a9f044f2eb33859b442a8aea76"></a><br/></td></tr>
<tr class="memitem:a0e59c760a0a4edacb437621ac66be25a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a0e59c760a0a4edacb437621ac66be25a">get_corrected_query_string</a> () const </td></tr>
<tr class="memdesc:a0e59c760a0a4edacb437621ac66be25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spelling-corrected query string.  <a href="#a0e59c760a0a4edacb437621ac66be25a"></a><br/></td></tr>
<tr class="memitem:a89f9d15f38538a07497fdfc8658852b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f9d15f38538a07497fdfc8658852b2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a89f9d15f38538a07497fdfc8658852b2">get_description</a> () const </td></tr>
<tr class="memdesc:a89f9d15f38538a07497fdfc8658852b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing this object. <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query.">Xapian::Query</a> object from a user query string. </p>
</div><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">Xapian::QueryParser::feature_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum of feature flags. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde"></a>FLAG_BOOLEAN</em>&nbsp;</td><td>
<p>Support AND, OR, etc and bracketed subexpressions. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b"></a>FLAG_PHRASE</em>&nbsp;</td><td>
<p>Support quoted phrases. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd"></a>FLAG_LOVEHATE</em>&nbsp;</td><td>
<p>Support + and -. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d"></a>FLAG_BOOLEAN_ANY_CASE</em>&nbsp;</td><td>
<p>Support AND, OR, etc even if they aren't in ALLCAPS. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36"></a>FLAG_WILDCARD</em>&nbsp;</td><td>
<p>Support wildcards. </p>
<p>At present only right truncation (e.g. Xap*) is supported.</p>
<p>Currently you can't use wildcards with boolean filter prefixes, or in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation).</p>
<p>In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.2.x, you needed to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a>. In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.3.3, OP_WILDCARD was added and wildcards are now expanded when <a class="el" href="classXapian_1_1Enquire.html#aedb5fb761acc0bb2249bec375883a093" title="Get (a portion of) the match set for the current query.">Enquire::get_mset()</a> is called, with the expansion using the database being searched. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0"></a>FLAG_PURE_NOT</em>&nbsp;</td><td>
<p>Allow queries such as 'NOT apples'. </p>
<p>These require the use of a list of all documents in the database which is potentially expensive, so this feature isn't enabled by default. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7"></a>FLAG_PARTIAL</em>&nbsp;</td><td>
<p>Enable partial matching. </p>
<p>Partial matching causes the parser to treat the query as a "partially entered" search. This will automatically treat the final word as a wildcarded match, unless it is followed by whitespace, to produce more stable results from interactive searches.</p>
<p>Currently FLAG_PARTIAL doesn't do anything if the final word in the query has a boolean filter prefix, or if it is in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation). It also doesn't do anything if if the final word is part of a value range.</p>
<p>In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.2.x, you needed to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> object which database to expand wildcards from by calling <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a>. In <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.3.3, OP_WILDCARD was added and wildcards are now expanded when <a class="el" href="classXapian_1_1Enquire.html#aedb5fb761acc0bb2249bec375883a093" title="Get (a portion of) the match set for the current query.">Enquire::get_mset()</a> is called, with the expansion using the database being searched. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c"></a>FLAG_SPELLING_CORRECTION</em>&nbsp;</td><td>
<p>Enable spelling correction. </p>
<p>For each word in the query which doesn't exist as a term in the database, <a class="el" href="classXapian_1_1Database.html#a86b944dece96d7ada2446ae8952ee3a2" title="Suggest a spelling correction.">Database::get_spelling_suggestion()</a> will be called and if a suggestion is returned, a corrected version of the query string will be built up which can be read using <a class="el" href="classXapian_1_1QueryParser.html#a0e59c760a0a4edacb437621ac66be25a" title="Get the spelling-corrected query string.">QueryParser::get_corrected_query_string()</a>. The query returned is based on the uncorrected query string however - if you want a parsed query based on the corrected query string, you must call <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">QueryParser::parse_query()</a> again.</p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f"></a>FLAG_SYNONYM</em>&nbsp;</td><td>
<p>Enable synonym operator '~'. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b"></a>FLAG_AUTO_SYNONYMS</em>&nbsp;</td><td>
<p>Enable automatic use of synonyms for single terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b"></a>FLAG_AUTO_MULTIWORD_SYNONYMS</em>&nbsp;</td><td>
<p>Enable automatic use of synonyms for single terms and groups of terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched.">set_database()</a> for this to work. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea4c83dcc06ba2cd69c81521133dc68ff8"></a>FLAG_CJK_NGRAM</em>&nbsp;</td><td>
<p>Enable generation of n-grams from CJK text. </p>
<p>With this enabled, spans of CJK characters are split into unigrams and bigrams, with the unigrams carrying positional information. Non-CJK characters are split into words as normal.</p>
<p>The corresponding option needs to have been used at index time.</p>
<p>Flag added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.3.4 and 1.2.22, but this mode can be enabled in 1.2.8 and later by setting environment variable XAPIAN_CJK_NGRAM. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a"></a>FLAG_DEFAULT</em>&nbsp;</td><td>
<p>The default flags. </p>
<p>Used if you don't explicitly pass any to <em><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">parse_query()</a></em>. The default flags are FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE.</p>
<p>Added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.0.11. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Member Function Documentation</h2>
<a class="anchor" id="a8590431c481fe0eea43cd4ce619a0816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_boolean_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>grouping</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. </p>
<p>For example:</p>
<div class="fragment"><div class="line">qp.add_boolean_prefix(<span class="stringliteral">&quot;site&quot;</span>, <span class="stringliteral">&quot;H&quot;</span>);</div>
</div><!-- fragment --><p>This allows the user to restrict a search with site:xapian.org which will be converted to Hxapian.org combined with any probabilistic query with <code>Xapian::Query::OP_FILTER</code>.</p>
<p>If multiple boolean filters are specified in a query for the same prefix, they will be combined with the <code>Xapian::Query::OP_OR</code> operator. Then, if there are boolean filters for different prefixes, they will be combined with the <code>Xapian::Query::OP_AND</code> operator.</p>
<p>Multiple fields can be mapped to the same prefix (so for example you can make site: and domain: aliases for each other). Instances of fields with different aliases but the same prefix will still be combined with the OR operator.</p>
<p>For example, if "site" and "domain" map to "H", but author maps to "A", a search for "site:foo domain:bar author:Fred" will map to "(Hfoo OR Hbar) AND Afred".</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code>Xapian::Query::OP_OR</code>.</p>
<p>Calling this method with an empty string for <em>field</em> will cause a <code><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">Xapian::InvalidArgumentError</a></code>.</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a8590431c481fe0eea43cd4ce619a0816" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way.">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
    <tr><td class="paramname">grouping</td><td>Controls how multiple filters are combined - filters with the same grouping value are combined with OP_OR, then the resulting queries are combined with OP_AND. If NULL, then <em>field</em> is used for grouping. If an empty string, then a unique grouping is created for each filter (this is sometimes useful when each document can have multiple terms with this prefix). [default: NULL] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4829ddcaa0582ff94d1066870a18c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a probabilistic term prefix. </p>
<p>For example:</p>
<div class="fragment"><div class="line">qp.add_prefix(<span class="stringliteral">&quot;author&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);</div>
</div><!-- fragment --><p>This allows the user to search for author:Orwell which will be converted to a search for the term "Aorwell".</p>
<p>Multiple fields can be mapped to the same prefix. For example, you can make title: and subject: aliases for each other.</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code>Xapian::Query::OP_OR</code>.</p>
<p>If any prefixes are specified for the empty field name (i.e. you call this method with an empty string as the first parameter) these prefixes will be used for terms without a field specifier. If you do this and also specify the <code>default_prefix</code> parameter to <code><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">parse_query()</a></code>, then the <code>default_prefix</code> parameter will override.</p>
<p>If the prefix parameter is empty, then "field:word" will produce the term "word" (and this can be one of several prefixes for a particular field, or for terms without a field specifier).</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix.">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a8590431c481fe0eea43cd4ce619a0816" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way.">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8f8583a9f044f2eb33859b442a8aea76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_valuerangeprocessor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *&#160;</td>
          <td class="paramname"><em>vrproc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a <a class="el" href="classXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors.">ValueRangeProcessor</a>. </p>
<p>This method is provided for API compatibility with <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.2.x and is deprecated - use <em><a class="el" href="classXapian_1_1QueryParser.html#af8e15e0a73460b2134ca202273d513b9" title="Register a RangeProcessor.">add_rangeprocessor()</a></em> with a <a class="el" href="classXapian_1_1RangeProcessor.html" title="Base class for range processors.">RangeProcessor</a> instead. </p>
<p>Compatibility shim. </p>

<p>References <a class="el" href="namespaceXapian.html#a0a75ef120e641c77f703e60f595ffda2">Xapian::BAD_VALUENO</a>, and <a class="el" href="classXapian_1_1RangeProcessor.html#a4e84753e4553ae7515edb4ef12da55b0">Xapian::RangeProcessor::operator()()</a>.</p>

</div>
</div>
<a class="anchor" id="a0e59c760a0a4edacb437621ac66be25a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::QueryParser::get_corrected_query_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spelling-corrected query string. </p>
<p>This will only be set if FLAG_SPELLING_CORRECTION is specified when <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">QueryParser::parse_query()</a> was last called.</p>
<p>If there were no corrections, an empty string is returned. </p>

</div>
</div>
<a class="anchor" id="a4a6323a8aea7734e447de1ba7eab31c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> Xapian::QueryParser::get_default_op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current default operator. </p>

</div>
</div>
<a class="anchor" id="a73d32cc7f862ab2e3fdd7da61f352fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::QueryParser::parse_query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_prefix</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query_string</td><td>A free-text query as entered by a user </td></tr>
    <tr><td class="paramname">flags</td><td>Zero or more Query::feature_flag specifying what features the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string.">QueryParser</a> should support. Combine multiple values with bitwise-or (|) (default FLAG_DEFAULT). </td></tr>
    <tr><td class="paramname">default_prefix</td><td>The default term prefix to use (default none). For example, you can pass "A" when parsing an "Author" field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the query string can't be parsed, then <a class="el" href="classXapian_1_1QueryParserError.html" title="Indicates a query string can&#39;t be parsed.">Xapian::QueryParserError</a> is thrown. You can get an English error message to report to the user by catching it and calling get_msg() on the caught exception. The current possible values (in case you want to translate them) are:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>Unknown range operation </li>
<li>parse error </li>
<li>Syntax: &lt;expression&gt; AND &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; AND NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; NOT &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; OR &lt;expression&gt; </li>
<li>Syntax: &lt;expression&gt; XOR &lt;expression&gt; </li>
</ul>

</div>
</div>
<a class="anchor" id="a576d221ba746506e51d9ea596ecb2cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_database </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the database being searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>The database to use for spelling correction (FLAG_SPELLING_CORRECTION), and synonyms (FLAG_SYNONYM, FLAG_AUTO_SYNONYMS, and FLAG_AUTO_MULTIWORD_SYNONYMS). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2efe48be88c4872afec4bc963f417ea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_default_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td>
          <td class="paramname"><em>default_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_op</td><td>The operator to use to combine non-filter query items when no explicit operator is used.</td></tr>
  </table>
  </dd>
</dl>
<p>So for example, 'weather forecast' is parsed as if it were 'weather OR forecast' by default.</p>
<p>The most useful values for this are OP_OR (the default) and OP_AND. OP_NEAR, OP_PHRASE, OP_ELITE_SET and OP_SYNONYM are also permitted. Passing other values will result in <a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API.">InvalidArgumentError</a> being thrown. </p>

</div>
</div>
<a class="anchor" id="afabe68a4eb93a05150ae7cf070d33752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_max_expansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>max_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_type</em> = <code><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">Xapian::Query::WILDCARD_LIMIT_ERROR</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a>|<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the maximum expansion of a wildcard and/or partial term. </p>
<p>Note: you must also set FLAG_WILDCARD and/or FLAG_PARTIAL in the flags parameter to <em><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query.">parse_query()</a></em> for this setting to have anything to affect.</p>
<p>If you don't call this method, the default settings are no limit on wildcard expansion, and partial terms expanding to the most frequent 100 terms - i.e. as if you'd called:</p>
<p>set_max_expansion(0); set_max_expansion(100, Xapian::Query::WILDCARD_LIMIT_MOST_FREQUENT, Xapian::QueryParser::FLAG_PARTIAL);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_expansion</td><td>The maximum number of terms each wildcard in the query can expand to, or 0 for no limit (which is the default). </td></tr>
    <tr><td class="paramname">max_type</td><td><em><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a" title="Throw an error if OP_WILDCARD exceeds its expansion limit.">Xapian::Query::WILDCARD_LIMIT_ERROR</a></em>, <em><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aaa08d373f6c100bdbff9420dc51a621f2" title="Stop expanding when OP_WILDCARD reaches its expansion limit.">Xapian::Query::WILDCARD_LIMIT_FIRST</a></em> or <em><a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aaa1568bc15280d8c8a10128d3b7f1db71" title="Limit OP_WILDCARD expansion to the most frequent terms.">Xapian::Query::WILDCARD_LIMIT_MOST_FREQUENT</a></em> (default: <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a" title="Throw an error if OP_WILDCARD exceeds its expansion limit.">Xapian::Query::WILDCARD_LIMIT_ERROR</a>). </td></tr>
    <tr><td class="paramname">flags</td><td>What to set the limit for (default: FLAG_WILDCARD|FLAG_PARTIAL, setting the limit for both wildcards and partial terms). </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="classXapian_1_1QueryParser.html#a0a2651e3363f82933b5c6e350bab6d8b">set_max_wildcard_expansion()</a>.</p>

</div>
</div>
<a class="anchor" id="a0a2651e3363f82933b5c6e350bab6d8b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_max_wildcard_expansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a4464380f6fa0055b5f26b8d03ae170e2">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>max_expansion</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specify the maximum expansion of a wildcard. </p>
<p>If any wildcard expands to more than <em>max_expansion</em> terms, an exception will be thrown.</p>
<p>This method is provided for API compatibility with <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.2.x and is deprecated - replace it with:</p>
<p>set_max_wildcard_expansion(max_expansion, <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a" title="Throw an error if OP_WILDCARD exceeds its expansion limit.">Xapian::Query::WILDCARD_LIMIT_ERROR</a>, <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36" title="Support wildcards.">Xapian::QueryParser::FLAG_WILDCARD</a>); </p>

<p>References <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a>, <a class="el" href="classXapian_1_1QueryParser.html#afabe68a4eb93a05150ae7cf070d33752">set_max_expansion()</a>, and <a class="el" href="classXapian_1_1Query.html#a7d8b24e46a691bea139d347bc6102a9aa4e374000be4ce7c0f319e335b008c19a">Xapian::Query::WILDCARD_LIMIT_ERROR</a>.</p>

</div>
</div>
<a class="anchor" id="a2312c9865a58cc1149fe7cda9f0c2585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemmer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;&#160;</td>
          <td class="paramname"><em>stemmer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stemmer. </p>
<p>This sets the stemming algorithm which will be used by the query parser. The stemming algorithm will be used according to the stemming strategy set by <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy.">set_stemming_strategy()</a>. As of 1.3.1, this defaults to STEM_SOME, but in earlier versions the default was STEM_NONE. If you want to work with older versions, you should explicitly set a stemming strategy as well as setting a stemmer, otherwise your stemmer won't actually be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stemmer</td><td>The <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm.">Xapian::Stem</a> object to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7dc3b55b6083bd3ff98fc8b2726c8fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemming_strategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stemming strategy. </p>
<p>This controls how the query parser will apply the stemming algorithm. Note that the stemming algorithm is only applied to words in probabilistic fields - boolean filter terms are never stemmed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td>The strategy to use - possible values are:<ul>
<li>STEM_NONE: Don't perform any stemming. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> &lt;= 1.3.0)</li>
<li>STEM_SOME: <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm.">Stem</a> all terms except for those which start with a capital letter, or are followed by certain characters (currently: <code>(/@&lt;&gt;=*[{"</code> ), or are used with operators which need positional information. Stemmed terms are prefixed with 'Z'. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> &gt;= 1.3.1)</li>
<li>STEM_ALL: <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm.">Stem</a> all terms (note: no 'Z' prefix is added).</li>
<li>STEM_ALL_Z: <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm.">Stem</a> all terms (note: 'Z' prefix is added). (new in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library.">Xapian</a> 1.2.11 and 1.3.1) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1046610676f72ba564108f0df5d77ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stopper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *&#160;</td>
          <td class="paramname"><em>stop</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stopper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop</td><td>The <a class="el" href="classXapian_1_1Stopper.html" title="Base class for stop-word decision functor.">Stopper</a> object to set (default NULL, which means no stopwords). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="queryparser_8h.html">queryparser.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<address><small>
Documentation for Xapian (version 1.4.0).<br>
Generated on Sat Jun 25 2016 by
<a href="http://www.doxygen.org/">Doxygen 1.8.1.2</a>.
</small></address>
</body>
</html>
